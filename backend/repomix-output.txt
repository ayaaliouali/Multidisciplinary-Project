This file is a merged representation of the entire codebase, combined into a single document by Repomix.

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)

Additional Info:
----------------

================================================================
Directory Structure
================================================================
.env.example
.gitignore
index.js
package.json
src/controller/admin/adminProductController.js
src/controller/admin/adminUserController.js
src/controller/auth.js
src/controller/commentsController.js
src/controller/message.controller.js
src/controller/product.js
src/controller/user.js
src/lib/cloudinary.js
src/middlewares/auth.js
src/models/Cart.js
src/models/Comment.js
src/models/message.model.js
src/models/Product.js
src/models/user.js
src/routes/admin/adminProductRoutes.js
src/routes/admin/adminUserRoutes.js
src/routes/auth.js
src/routes/cartRoutes.js
src/routes/comment.js
src/routes/message.route.js
src/routes/productRoutes.js
src/routes/user.js
src/socket.js

================================================================
Files
================================================================

================
File: .env.example
================
MONGO_DB_URL= mongodb://localhost:27017
JWT_SECRET=1QdkVNoySqb0kWXX7M6OF2y4pqi53vTpcWrVLTNp5
CLOUDINARY_CLOUD_NAME=dpyelu966
CLOUDINARY_API_KEY=693687163298186
CLOUDINARY_API_SECRET=1ZO7cywvp7Wm3sWR1gqtD1i-oso

================
File: .gitignore
================
node_modules
.env

================
File: index.js
================
import dotenv from "dotenv";
dotenv.config();
console.log("1) Loaded JWT_SECRET:", JSON.stringify(process.env.JWT_SECRET));
import express from 'express';
import http from 'http';
import { Server } from 'socket.io';
import cors from 'cors';
import bodyParser from 'body-parser';

import connectDB from'./src/config/db.js';
import { setSocketIO } from './src/socket.js'; 
import authRouter from './src/routes/auth.js';     
import userRouter from './src/routes/user.js'; 
import messageRouter from './src/routes/message.route.js'; 
import helmet from "helmet";
import rateLimit from "express-rate-limit";
import productRoutes  from './src/routes/productRoutes.js';
import adminProductRoutes  from "./src/routes/admin/adminProductRoutes.js";
import CartRoutes  from './src/routes/cartRoutes.js';
import comments  from './src/routes/comment.js';


const app = express();
const server = http.createServer(app);

const io = new Server(server, {
  cors: {
    origin: "*", 
    methods: ["GET", "POST"]
  }
});

setSocketIO(io);

app.set('trust proxy', 1); 
app.use(bodyParser.json());
app.use(bodyParser.urlencoded({ extended: true }));
app.use(cors());
app.use(helmet());
app.set('trust proxy', 1); 


const limiter = rateLimit({
  windowMs: 10 * 60 * 1000,//10 minutes
  max: 100,
});

app.use(limiter);

app.get("/",(req,res)=>{
  res.send("Express.js is running successfully")
});

app.use('/auth',authRouter);
app.use("/users",userRouter);
app.use("/message",messageRouter);
app.use('/api/products',productRoutes, adminProductRoutes);
app.use('/api/cart', CartRoutes);
app.use('/api/v1/comments', comments);


io.on("connection", (socket) => {
  console.log("🔌 New user connected:", socket.id);

  socket.on("joinRoom", ({ senderId, receiverId }) => {
    const roomId = [senderId, receiverId].sort().join("-");
    socket.join(roomId);
    console.log(`User joined room: ${roomId}`);
  });

  socket.on("disconnect", () => {
    console.log("❌ User disconnected:", socket.id);
  });
});   

connectDB();

app.listen(4000, () => {
    console.log("Server is running on port 4000");
});

================
File: package.json
================
{
  "name": "multidisciplinary-project",
  "version": "1.0.0",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "description": "",
  "type": "module",
  "dependencies": {
    "bcrypt": "^5.1.1",
    "body-parser": "^1.20.3",
    "cloudinary": "^2.6.0",
    "cors": "^2.8.5",
    "dotenv": "^16.5.0",
    "express": "^4.21.2",
    "express-rate-limit": "^7.5.0",
    "express-validator": "^7.2.1",
    "helmet": "^8.1.0",
    "jsonwebtoken": "^9.0.2",
    "mongoose": "^8.15.1",
    "multer": "^1.4.5-lts.2",
    "nodemon": "^3.1.9",
    "socket.io": "^4.8.1",
    "soket.io": "^0.0.1-security"
  }
}

================
File: src/controller/admin/adminProductController.js
================
import Product from '../../models/Product.js';

export const createProduct = async (req, res) => {
  try {
    const product = new Product(req.body);
    await product.save();
    res.status(201).json(product);
  } catch (err) {
    res.status(400).json({ message: err.message });
  }
}; 


export async function getProduct(req,res){

  try {
    const products = await Product.findById(req.params.id);
    res.json(products);
  } catch (err) {
    res.status(500).json({ message: err.message });
  }
};


export const getAllProducts = async (req, res) => {
  try {
    const products = await Product.find();
    res.json(products);
  } catch (err) {
    res.status(500).json({ message: err.message });
  }
};


export const updateProduct = async (req, res) => {
  try {
    const product = await Product.findByIdAndUpdate(
      req.params.id,
      req.body,
      { new: true }
    );
    if (!product) {
      return res.status(404).json({ message: ' product not found ' });
    }
    res.json(product);
  } catch (err) {
    res.status(400).json({ message: err.message });
  }
};


export const deleteProduct = async (req, res) => {
  try {
    const product = await Product.findByIdAndDelete(req.params.id);
    if (!product) {
      return res.status(404).json({ message: ' product not found ' });
    }
    res.json({ message: 'the product is deleted  ' });
  } catch (err) {
    res.status(500).json({ message: err.message});
}
};

================
File: src/controller/admin/adminUserController.js
================
import User from "../models/user.js";

export const getAllUsers = async (req, res) => {
  try {
    const users = await User.find();
    res.json(users);
  } catch (err) {
    res.status(400).json({ message: err.message });
  }
};

export async function deleteUser(req, res) {
  try {
    const user = await User.findByIdAndDelete(req.params.id);

    if (!user) {
      return res.status(404).json({ message: "User not found" });
    }

    res.json({ message: "User deleted successfully" });
  } catch (error) {
    res.status(500).json({ message: error.message });
  }
}

================
File: src/controller/auth.js
================
import User from "../models/user.js";
import jwt from "jsonwebtoken";
import bcrypt from "bcrypt";

const generateToken = (user) => {
  return jwt.sign(
    { id: user._id, role: user.role },
    "KEY",
    { expiresIn: "30d" }
  );
};

export async function login(req, res) {
  try {
    const { email, password } = req.body;

    // Validate inputs
    if (!email || !password) {
      return res.status(400).json({ message: 'Email and password are required.' });
    }

    


    // Find user
    const user = await User.findOne({ email:email});
    if (!user) {
      console.error(`Login failed: No user found for email ${sanitizedEmail}`);
      return res.status(400).json({ message: 'Invalid credentials' });
    }

    // Compare passwords
    const isMatch = await bcrypt.compare(password, user.password);
    if (!isMatch) {
      console.error(`Login failed: Incorrect password for email ${sanitizedEmail}`);
      return res.status(400).json({ message: 'Invalid credentials' });
    }

    // Generate token
    const token = generateToken(user);
    console.log('🔑 Newly signed token:', token);

    // Return only necessary fields
    res.status(200).json({
      message: 'Login successful',
      data: {
        token,
        name: user.name,
        email: user.email,
      },
    });
  } catch (error) {
    console.error('Login error:', error);
    res.status(500).json({ message: 'Server error. Please try again later.' });
  }
}


export async function register(req,res){
 try {
      const {name,email,password} = req.body;
      if (!name || !email || !password) {
      return res.status(400).json({ message: "All fields are required." });
    }
      const existingUser = await User.findOne({email});
     if(existingUser){
        return res.status(400).json ({message:"Email already exists"});
}
const hashedPassword = await bcrypt.hash(password,10)
const user = new User({name,email,password:hashedPassword})
await user.save();
    const token = generateToken(user);
    delete user._doc.password;
    res.status(201).json({data: { token, ...user._doc },message:"Your Account Created Successfully"})
 } catch (error) {
    console.log(error);
      res.status(500).json({message:error.message});
 }
}

================
File: src/controller/commentsController.js
================
import Comment from '../models/Comment.js';
import { validationResult } from'express-validator';


export const createComment = async (req, res, next) => {
  const errors = validationResult(req);
  if (!errors.isEmpty()) {
    return res.status(400).json({ errors: errors.array() });
  }

  try {
    const { product, rating, comment } = req.body;
    
    const newComment = await Comment.create({
      product,
      user: req.user.id,
      rating,
      comment
    });

    res.status(201).json({
      success: true,
      data: newComment
    });
  } catch (err) {
    next(err);
  }
};


export const getProductComments = async (req, res, next) => {
  try {
    const comments = await Comment.find({ product: req.params.productId })
      .sort({ createdAt: -1 })
      .populate('user', 'name email');

    res.status(200).json({
      success: true,
      count: comments.length,
      data: comments
    });
  } catch (err) {
    next(err);
  }
};


export const updateComment = async (req, res, next) => {
  try {
    let comment = await Comment.findById(req.params.id);

    if (!comment) {
      return res.status(404).json({
        success: false,
        error: 'Comment not found'
      });
    }

    
    if (comment.user.toString() !== req.user.id) {
      return res.status(401).json({
        success: false,
        error: 'Not authorized to update this comment'
      });
    }

    comment = await Comment.findByIdAndUpdate(req.params.id, req.body, {
      new: true,
      runValidators: true
    });

    res.status(200).json({
      success: true,
      data: comment
    });
  } catch (err) {
    next(err);
  }
};


export const deleteComment = async (req, res, next) => {
  try {
    const comment = await Comment.findById(req.params.id);

    if (!comment) {
      return res.status(404).json({
        success: false,
        error: 'Comment not found'
      });
    }

    
    if (comment.user.toString() !== req.user.id) {
      return res.status(401).json({
        success: false,
        error: 'Not authorized to delete this comment'
      });
    }

    await comment.remove();

    res.status(200).json({
      success: true,
      data: {}
    });
  } catch (err) {
    next(err);
  }
};


export const getAverageRating = async (req, res, next) => {
  try {
    const stats = await Comment.aggregate([
      {
        $match: { product: mongoose.Types.ObjectId(req.params.productId) }
      },
      {
        $group: {
          _id: '$product',
          averageRating: { $avg: '$rating' },
          totalRatings: { $sum: 1 }
        }
      }
    ]);

    if (stats.length === 0) {
      return res.status(200).json({
        success: true,
        data: {
          averageRating: 0,
          totalRatings: 0
        }
      });
    }

    res.status(200).json({
      success: true,
      data: stats[0]
    });
  } catch (err) {
    next(err);
}
};

================
File: src/controller/message.controller.js
================
import Message from "../models/message.model.js";
import User from "../models/user.js";
import cloudinary from "../lib/cloudinary.js";
import { getSocketIO } from "../socket.js";


export async function  getUsersForSidebar (req,res){
    try {
        const loggedInUserId = req.user._id;
        const filteredUsers = await User.find({_id:{$ne:loggedInUserId}}).select("-password");

        res.status(200).json(filteredUsers);
    } catch (error) {
        console.log("Error in getUsersForSidebar:",error.message);
        res.status(500).json({error:"Internal server error"});
    }
}

export async function getMessages (req,res){
    try {
        const { id:userToChatId } = req.params;
        const myId = req.user._id;

  const messages = await Message.find({
    $or: [
        { senderId: myId, receiverId: userToChatId },
        { senderId: userToChatId, receiverId: myId }
    ]
});
        res.status(200).json(messages);  
    } catch (error) {
        console.log("Error in getMessages:",error.message);
        res.status(500).json({error:"Internal server error"});
    }
}

export async function sendMessages(req,res) {

    try {
 const { text,image } = req.body;
 const { id: receiverId} = req.params;
 const senderId = req.user._id;
 let imageUrl;
if(image){ 
    //cloudinary thti fih image yrdhalk url
    const uploadResponse = await cloudinary.uploader.upload(image);
    imageUrl = uploadResponse.secure_url;
}  
    
            const newMessage = new Message({
                senderId,
                receiverId,
                text,
                image:imageUrl
            });
    
            await newMessage.save();

            // todo:realtime functionality goes here => socket.io

            const io = getSocketIO();
    const roomId = [senderId.toString(), receiverId.toString()].sort().join("-");
    io.to(roomId).emit("newMessage", newMessage);
    
            res.status(200).json(newMessage);      
    } catch (error) {
        console.log("Error in sendMessage:",error.message);
        res.status(500).json({error:"Internal server error"});
    }
}

================
File: src/controller/product.js
================
import Product from '../models/Product.js';






export const getAllProducts = async (req, res) => {
  try {
    const products = await Product.find();
    res.json(products);
  } catch (err) {
    res.status(500).json({ message: err.message });
  }
};

================
File: src/controller/user.js
================
import User from "../models/user.js";

export async function createUser(req,res){
    try {
        const{ name,email,password } = req.body;
        const user = await User.create({ name,email,password});
        if(!user){
            return res.status(400).json({message:"User not created"})
        }
        res.status(201).json(user);
    } catch (error) {
        res.status(500).json({message : error.message });
    }
}



export async function getUserById(req, res) {
  try {
    const user = await User.findById(req.params.id);

    if (!user) {
      return res.status(404).json({ message: "User not found" });
    }
    if (req.user.role !== 'admin' && req.user._id.toString() !== user._id.toString()) {
      return res.status(403).json({ message: "Access denied" });
    }
     res.json(user);
  } catch (error) {
    res.status(500).json({ message: error.message });
  }
}

export async function updateUser(req, res) {
  try {
    const user = await User.findById(req.params.id);

    if (!user) {
      return res.status(404).json({ message: "User not found" });
    }

    if (req.user.role !== 'admin' && req.user._id.toString() !== user._id.toString()) {
      return res.status(403).json({ message: "Access denied" });
    }

    user.name = req.body.name || user.name;
    user.email = req.body.email || user.email;
    user.password = req.body.password || user.password;

    const updatedUser = await user.save();
    res.json(updatedUser);
  } catch (error) {
    res.status(500).json({ message: error.message });
  }
}

================
File: src/lib/cloudinary.js
================
import { v2 as cloudinary } from "cloudinary";

import { config } from "dotenv";

config();

cloudinary.config({
  cloud_name: process.env.CLOUDINARY_CLOUD_NAME,
  api_key: process.env.CLOUDINARY_API_KEY,
  api_secret: process.env.CLOUDINARY_API_SECRET,
});

export default cloudinary;

================
File: src/middlewares/auth.js
================
import jwt from "jsonwebtoken";
import User from "../models/user.js";



export const protect = async (req,res,next)=>{
try {
    let token ;
    if (req.headers.authorization) {
        token = req.headers.authorization.split(" ")[1];
        console.log("2) Verifying with JWT_SECRET:", JSON.stringify(process.env.JWT_SECRET));
        console.log("📨 Token received:", token);
        const decoded = jwt.verify (token , process.env.JWT_SECRET);
      console.log("JWT payload:", decoded);
      const user = await User.findById(decoded.id);
        if (!user) {
            return res.status(401).json({ message: "Unauthorized" });
        } 
        req.user = user;
        next();
   
    }     
} catch (error) {
     console.log (error);
        return res.status(500).json(
            {message:error.message})
}
};

export const isAdmin = (req, res, next) => {
  if (req.user && req.user.role === 'admin') {
    next();
  } else {
    res.status(403).json({ message: 'Admin access only' });
  }
};

================
File: src/models/Cart.js
================
import mongoose from 'mongoose';


const cartItemSchema = new mongoose.Schema({
  product: { type: mongoose.Schema.Types.ObjectId, ref: 'Product', required: true },
  quantity: { type: Number, default: 1 }
});

const cartSchema = new mongoose.Schema({
  user: { type: String, required: true, unique: true },
  items: [cartItemSchema],
  createdAt: { type: Date, default: Date.now }
});

export default mongoose.model('Cart', cartSchema);

================
File: src/models/Comment.js
================
import mongoose from'mongoose';

const commentSchema = new mongoose.Schema({
  product: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Product',
    required: [true, 'Product ID is required']
  },
  user: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User',
    required: [true, 'User ID is required']
  },
  rating: {
    type: Number,
    required: [true, 'Rating is required'],
    min: [1, 'Rating must be at least 1'],
    max: [5, 'Rating cannot exceed 5']
  },
  comment: {
    type: String,
    required: [true, 'Comment text is required'],
    maxlength: [500, 'Comment cannot exceed 500 characters']
  },
  createdAt: {
    type: Date,
    default: Date.now
  }
}, {
  toJSON: { virtuals: true },
  toObject: { virtuals: true }
});


commentSchema.index({ product: 1, createdAt: -1 });
commentSchema.index({ user: 1 });

const Comment = mongoose.model('Comment', commentSchema);

export default Comment;

================
File: src/models/message.model.js
================
import mongoose from "mongoose";

const messageSchema = new mongoose.Schema ({

    senderId : {
        type : mongoose.Schema.Types.ObjectId,
        ref:"User",
        required : true,
    },
    receiverId : {
        type : mongoose.Schema.Types.ObjectId,
        ref:"User",
        required : true,
    },
    text : {
        type : String,
    },
    image : {
        type : String,
    },

},
{ timestamps :true }
)

const Message = mongoose.model("Message", messageSchema);

export default Message;

================
File: src/models/Product.js
================
import mongoose from 'mongoose';
import  router from '../routes/auth.js';

const productSchema = new mongoose.Schema({
  name: { type: String, required: true },
  price: { type: Number, required: true },
  description: { type: String },
  image: { type: String }
});

const product = mongoose.model('Product', productSchema);
export default product;

================
File: src/models/user.js
================
import mongoose from "mongoose";

const userSchema = new mongoose.Schema({
  name :{
       type : String,
       required : true,
       validate: {
      validator: function (value) {
        return value.length > 3 && value.length < 20;
      },
      message: "Name must be between 4 and 19 characters."
    }
  },
  email :{
       type : String,
       required : true,
       unique : true,
         validate: {
      validator: function (value) {
        return value.includes("@");
      },
      message: "Email must include @ symbol."
    }
  },
    password :{
        type : String,
        required : true,
    
    },
     role: {
    type: String,
    enum: ['user', 'admin'],
    default: 'user'
  }

});
const User = mongoose. model("User", userSchema);
export default User;

================
File: src/routes/admin/adminProductRoutes.js
================
import express from 'express';
import {
  createProduct,
  getAllProducts,
  getProduct,
  updateProduct,
  deleteProduct
} from '../../controller/admin/adminProductController.js';
import { isAdmin } from '../../middlewares/auth.js';

const router = express.Router();

router.post('/', isAdmin, createProduct);        
router.get('/A', isAdmin, getAllProducts); 
router.get('/:id', isAdmin, getProduct); 
router.put('/:id', isAdmin, updateProduct);     
router.delete('/:id', isAdmin, deleteProduct);   

export default router;

================
File: src/routes/admin/adminUserRoutes.js
================
import express from 'express';
import { protect, isAdmin } from '../middlewares/auth.js';
import {getAllUsers,deleteUser,} from '../controllers/userController.js';

const router = express.Router();
//admin only
router.get('/', protect, isAdmin, getAllUsers);
//admin only
router.delete('/:id', protect, isAdmin, deleteUser);

export default router;

================
File: src/routes/auth.js
================
import { Router } from "express";
import {login ,register} from "../controller/auth.js";

const router = Router();

router.post("/login" , login);
router.post("/register", register);

export default router;

================
File: src/routes/cartRoutes.js
================
import express from 'express';
import Cart from'../models/Cart.js';
import Product from'../models/Product.js';
const router = express.Router();


router.get('/:userId', async (req, res) => {
  try {
    const cart = await Cart.findOne({ user: req.params.userId }).populate('items.product');
    if (!cart) {
      return res.status(404).json({ message: 'Cart not found' });
    }
    res.json(cart);
  } catch (err) {
    res.status(500).json({ message: err.message });
  }
});


router.post('/:userId/add', async (req, res) => {
  const { productId, quantity } = req.body;
  
  try {
    const product = await Product.findById(productId);
    if (!product) {
      return res.status(404).json({ message: 'Product not found' });
    }

    let cart = await Cart.findOne({ user: req.params.userId });

    if (!cart) {
      cart = new Cart({ user: req.params.userId, items: [] });
    }

    const existingItem = cart.items.find(item => item.product.toString() === productId);

    if (existingItem) {
      existingItem.quantity += quantity || 1;
    } else {
      cart.items.push({ product: productId, quantity: quantity || 1 });
    }

    await cart.save();
    res.json(await cart.populate('items.product'));
  } catch (err) {
    res.status(400).json({ message: err.message });
  }
});


router.post('/:userId/remove', async (req, res) => {
  const { productId } = req.body;
  
  try {
    const cart = await Cart.findOne({ user: req.params.userId });

    if (!cart) {
      return res.status(404).json({ message: 'Cart not found' });
    }

    cart.items = cart.items.filter(item => item.product.toString() !== productId);
    await cart.save();
    res.json(await cart.populate('items.product'));
  } catch (err) {
    res.status(400).json({ message: err.message });
  }
});


router.post('/:userId/update', async (req, res) => {
  const { productId, quantity } = req.body;
  
  try {
    const cart = await Cart.findOne({ user: req.params.userId });

    if (!cart) {
      return res.status(404).json({ message: 'Cart not found' });
    }

    const item = cart.items.find(item => item.product.toString() === productId);
    if (!item) {
      return res.status(404).json({ message: 'Item not found in cart' });
    }

    item.quantity = quantity;
    await cart.save();
    res.json(await cart.populate('items.product'));
  } catch (err) {
    res.status(400).json({ message: err.message });
  }
});

export default router;

================
File: src/routes/comment.js
================
import  express from'express';
import { protect } from '../middlewares/auth.js';

import { check } from'express-validator';
import {
  createComment,
  getProductComments,
  updateComment,
  deleteComment,
  getAverageRating
} from '../controller/commentsController.js';


const router = express.Router();

const commentValidation = [
  check('product', 'Product ID is required').not().isEmpty(),
  check('rating', 'Please include a rating between 1 and 5').isInt({ min: 1, max: 5 }),
  check('comment', 'Comment must be between 10 and 500 characters').isLength({ min: 10, max: 500 })
];

      
router.post('/',  commentValidation, createComment);
router.get('/product/:productId', getProductComments);
router.get('/product/:productId/average', getAverageRating);
router.put('/:id', protect, commentValidation, updateComment); 
router.delete('/:id', protect, deleteComment);

export default router;

================
File: src/routes/message.route.js
================
import { Router } from "express";

import {protect as protectRouter } from "../middlewares/auth.js";

import { getUsersForSidebar, getMessages, sendMessages } from "../controller/message.controller.js";

const router = Router();
// hado l users li ykouno fl left side
router.get("/users",protectRouter,getUsersForSidebar)
//hadi t3 les msg ki yjio tht b3dahoum fl conv
router.get("/:id", protectRouter,getMessages)

router.post("/send/:id",protectRouter,sendMessages)

export default router;

================
File: src/routes/productRoutes.js
================
import { Router } from "express";
import {getAllProducts} from "../controller/product.js";
import { protect } from "../middlewares/auth.js";

const router = Router();


router.get('/All', protect, getAllProducts);


export default router;

================
File: src/routes/user.js
================
import { Router } from "express";
import {createUser,getUserById,updateUser,} from "../controller/user.js";
import { protect } from "../middlewares/auth.js";

const router = Router();

router.post("/", createUser);
router.get("/:id", protect, getUserById);
router.put("/:id", protect, updateUser);

export default router;

================
File: src/socket.js
================
let io;

export const setSocketIO = (ioInstance) => {
  io = ioInstance;
};

export const getSocketIO = () => io;




================================================================
End of Codebase
================================================================
